\chapter{Аналитическая часть}

В данном разделе производится постановка задачи и анализ методов решения поставленной задачи.

\section{Формализация задачи}

В соответствии с техническим задание на курсовую работу по курсу <<Операционные системы>> необходимо разработать загружаемый модуль ядра, который позволит посмотреть следующую информацию о состоянии системы:

\begin{itemize}
	\item количество системных вызовов за выбранный промежуток времени;
	\item загруженность оперативной памяти за выбранный промежуток времени;
	\item количество процессов в системе и их состояния на данный момент.
\end{itemize}

Для решение данной задачи необходимо:

\begin{itemize}
	\item проанализировать различные подходы к трассировке ядра  и перехвату функций;
	\item исследовать структуры и функции ядра, предоставляющие информацию о процессах и памяти;
	\item изучить основные принципы загружаемых модулей ядра.
\end{itemize}

\section{Трассировка ядра}

Трассировка ядра -- получение информации о том, что происходит внутри работающей системы. Для этого используются специальные программные инструменты, регистрирующие все происходящие события в системе.

Такие программы могут одновременно отслеживать события как на уровне отдельных приложений, так и на уровне операционной системы. Полученная в ходе трассировки информации может оказаться полезной для диагностики и решения системных проблем.

Во время трассировки записывается информация о событиях, происходящих на низком уровне. Их количество исчисляется сотнями и даже тысячами. 

Далее будут рассмотрены существующие различные подходы к трассировке ядра и перехвату вызываемых функций, и выбран наиболее подходящий для реализации в курсовой работе.

\subsection{Linux Security Module}

\texttt{Linux Security Module} (LSM) \cite{linux-security-api} -- это специальный интерфейс, созданный для перехвата функций. В критических местах кода ядра расположены вызовы security-функций, которые вызывают коллбеки (англ. callback \cite{callback}), установленные security-модулем. Данный модуль может изучать контекст операции и принимать решение о её разрешении или запрете \cite{linux-security-api}.

Особенности рассматриваемого интерфейса:

\begin{itemize}
	\item security-модули являются частью ядра и не могу быть загружены динамически;
	\item в стандартной конфигурации сборки ядра флаг наличия LSM неактивен - большинство уже готовых сборок ядра не содержут внутри себя интерфейс LSM;
	\item в системе может быть только один security-модуль \cite{linux-security-api}.
\end{itemize}

Таким образом, для использования Linux Security Module необходимо поставлять собственную сборку ядра Linux, что является трудоёмким вариантом -- как минимум, придётся тратить время на сборку ядра. Кроме того, данный интерфейс обладает излишним функционалом (например решение о блокировке какой-либо операции), который не потребуется в написании разрабатываемого модуля ядра.

\subsection{Модификация таблицы системных вызовов}

Все обработчики системных вызовов расположены в таблице \texttt{sys\_call\_table}. Подмена значений в этой таблице приведёт к смене поведения всей системы. Сохранив старое значение обработчика и подставив в таблицу собственный обработчик, можно перехватить любой системный вызов.

Особенности данного подхода:

\begin{itemize}
	\item минимальные накладные расходы;
	\item не требуется специальная конфигурация ядра;
	\item техническая сложность реализации -- необходимо модифицировать таблицу системных вызовов;
	\item из-за ряда оптимизаций, реализованных в ядре, некоторые обработчики невозможно перехватить \cite{habr-profiling-linux};
	\item можно перехватить только системные вызовы -- нельзя перехватить обычные функции.
\end{itemize}

\subsection{kprobes}

\texttt{kprobes} \cite{kprobes} -- специальный интерфейс, предназначенный для отладки и трассировки ядра. Данный интерфейс позволяет устанавливать пред- и пост-обработчики для любой инструкции в ядре, а так же обработчики на вход и возврат из функции. Обработчики получают доступ к регистрам и могут изменять их значение. Таким образом, \texttt{kprobes} можно использовать как и в целях мониторинга, так и для возможности повлиять на дальнейший ход работы ядра \cite{habr-profiling-linux}.

Особенности рассматриваемого интерфейса:

\begin{itemize}
	\item перехват любой инструкции в ядре -- это реализуется с помощью точек останова (инструкция \texttt{int3}), внедряемых в исполняемый код ядра. Таким образом, можно перехватить любую функцию в ядре;
	\item хорошо задокументированный API;
	\item нетривиальные накладные расходы -- для расстановки и обработки точек останова необходимо большое количество процессорного времени \cite{habr-profiling-linux};
	\item техническая сложность реализации. Так, например, чтобы получить аргументы функции или значения её локальных переменных нужно знать, в каких регистрах, или в каком месте на стеке они находятся, и самостоятельно их оттуда извлекать;
	\item при подмене адреса возврата из функции используется стек, реализованный с помощью буффера фиксированного размера. Таким образом, при большом количестве одновременных вызовов перехваченной функции, могут быть пропущены срабатывания.
\end{itemize}

\subsection{Kernel tracepoints}

\texttt{Kernel tracepoints} \cite{kernel-tracepoints} -- это фреймворк для трассировки ядра, реализованный через статическое инструментирование кода. Большинство важных функций ядра статически инструментировано -- в теле функций добавлены вызовы функций фреймворка рассматриваемого фреймворка.

Особенности рассматриваемого фреймворка:

\begin{itemize}
	\item минимальные накладные расходы -- необходимо только вызвать функцию трассировки в необходимом месте;
	\item отсутствие задокументированного API;
	\item не все функции ядра статически инструментированны; 
	\item не работает, если ядро не сконфигурировано должным образом \cite{habr-profiling-linux}.
\end{itemize}

\subsection{ftrace}

\texttt{ftrace} \cite{ftrace} -- это фреймворк для трассировки ядра на уровне функций, реализованный на основе ключей компилятора \texttt{-pg} \cite{ftrace-habr} и \texttt{mfentry} \cite{ftrace-habr}. Данные функции вставляют в начало каждой функции вызов специальной трассировочной функции \texttt{mcount()} или \texttt{\_\_fentry()\_\_}. В пользовательских программах данная возможность компилятора используется профилировщиками, с целью отслеживания всех вызываемых функций. В ядре эти функции используются исключительно для реализации рассматриваемого фреймворка.

Для большинства современных архитектур процессора доступна оптимизация: динамический \texttt{frace} \cite{ftrace-habr}. Ядро знает расположение всех вызовов функций \texttt{mcount()} или \texttt{\_\_fentry()\_\_} и на ранних этапах загрузки ядра подменяет их машинный код на специальную машинную инструкцию \texttt{NOP} \cite{NOP}, которая ничего не делает. При включении трассировки, в нужные функции необходимые вызовы добавляются обратно. Если \texttt{ftrace} не используется, его влияние на производительность системы минимально.

Особенности рассматриваемого фреймворка:

\begin{itemize}
	\item имеется возможность перехватить любую функцию;
	\item перехват совместим с трассировкой;
	\item фреймворк зависит от конфигурации ядра, но, в популярных конфигурациях ядра (и, соответственно, в популярных образах ядра) установлены все необходимые флаги для работы; 
\end{itemize}

\subsection*{Вывод}

В таблице 1.1 приведено сравнение приведенных выше технологий трассировки ядра. 

\begin{table}[h]
	\centering
	\label{tab:analyze}
	\begin{tabular}{ | p{3cm} | p{2cm} | p{2cm} | p{2cm} | p{2cm} | p{2cm} | }
		\hline
		Название & Дин. загрузка & Перехват любых функций & Любая конфигурация ядра & Простота реализации & Наличие документации \\
		\hline
		Linux Security Module & Нет & Да & Нет & Нет & Нет \\
		\hline
		Модификация таблицы системных вызовов & Да & Нет & Да & Нет & Нет \\
		\hline
		kprobes & Да & Да & Да & Нет & Да \\
		\hline
		kernel tracepoints & Да & Да & Нет & Да & Нет \\
		\hline
		ftrace & Да & Да & Нет & Да & Да \\
		\hline
	\end{tabular}
	\caption{Сравнение технологий, позволяющих трассировать ядро}
\end{table}

В ходе анализа подходов к перехвату функций, был выбран фреймворк \texttt{ftrace}, так как он позволяет перехватить любую функцию зная лишь её имя, может быть загружен в ядро динамически и не требует специальной сборки ядра и имеет хорошо задокументированный API.

\section{Информация о процессах и памяти}

\subsection{Структура \texttt{struct task\_struct}}

Информация о процессах в ядре хранится с помощью специальной структуры \texttt{struct task\_struct} \cite{task-struct}. Каждому процессу в системе соответствует структура \texttt{task\_struct}, которая полностью описывает процесс. Сами структуры связаны друг с другом по средствам кольцевого связанного списка. 

Структура описывает текущее состояние процесса, его флаги, указатель на процессы-потомки и так далее. Стоит отметить, что для описания потоков, в ядре Linux так же используется данная структура -- различие лишь в установленных флагах. В листинге \ref{lst:task-struct} представлено объявление структуры с наиболее интересными полями.\\

\begin{lstlisting}[label=lst:task-struct, caption=Листинг структуры task\_struct с наиболее интересными полями, language=c]
struct task_struct {
	#ifdef CONFIG_THREAD_INFO_IN_TASK
	struct thread_info		thread_info;
	#endif

	unsigned int			__state;
	...
	unsigned int			flags;
	...
	#ifdef CONFIG_SMP
	int				on_cpu;
	...
	int				recent_used_cpu;
	#endif
	...
	int				recent_used_cpu;
	...
	#ifdef CONFIG_CGROUP_SCHED
	struct task_group		*sched_task_group;
	#endif
	...
	struct sched_info		sched_info;
	...
	struct list_head		tasks;
	...
}
\end{lstlisting}

Для работы с данной структурой внутри ядра объявлен ряд макросов. Например, чтобы обойти все процессы в системе, существует макрос \texttt{for\_each\_process}, который итерируется по связанному списку процессов. Состояния процесса так же описываются с помощью специальных макросов. Кроме того, существует ряд макросов, позволяющих проверить текущее состояние процесса, например, узнать, выполняется ли процесс в данный момент. Список этих макросов приведён в листингах \ref{lst:states} - \ref{lst:state-macroses}.\\

\begin{lstlisting}[label=lst:states, caption=Описание состояний процесса с помощью макросов, language=c]
#define TASK_RUNNING			0x0000
#define TASK_INTERRUPTIBLE		0x0001
#define TASK_UNINTERRUPTIBLE		0x0002
#define __TASK_STOPPED			0x0004
#define __TASK_TRACED			0x0008
#define EXIT_DEAD			0x0010
#define EXIT_ZOMBIE			0x0020
#define EXIT_TRACE			(EXIT_ZOMBIE | EXIT_DEAD)
#define TASK_PARKED			0x0040
#define TASK_DEAD			0x0080
#define TASK_WAKEKILL			0x0100
#define TASK_WAKING			0x0200
#define TASK_NOLOAD			0x0400
#define TASK_NEW			0x0800
#define TASK_RTLOCK_WAIT		0x1000
#define TASK_STATE_MAX			0x2000
#define TASK_KILLABLE			(TASK_WAKEKILL | TASK_UNINTERRUPTIBLE)
#define TASK_STOPPED			(TASK_WAKEKILL | __TASK_STOPPED)
#define TASK_TRACED			(TASK_WAKEKILL | __TASK_TRACED)
#define TASK_IDLE			(TASK_UNINTERRUPTIBLE | TASK_NOLOAD)
#define TASK_NORMAL			(TASK_INTERRUPTIBLE | TASK_UNINTERRUPTIBLE)
#define TASK_REPORT			(TASK_RUNNING | TASK_INTERRUPTIBLE | \
TASK_UNINTERRUPTIBLE | __TASK_STOPPED | \
__TASK_TRACED | EXIT_DEAD | EXIT_ZOMBIE | \
TASK_PARKED)
\end{lstlisting}

\begin{lstlisting}[label=lst:state-macroses, caption=Макросы\, с помощью которых можно узнать текущее состояние процесса, language=c]
#define task_is_running(task)		(READ_ONCE((task)->__state) == TASK_RUNNING)
#define task_is_traced(task)		((READ_ONCE(task->__state) & __TASK_TRACED) != 0)
#define task_is_stopped(task)		((READ_ONCE(task->__state) & __TASK_STOPPED) != 0)
#define task_is_stopped_or_traced(task)	((READ_ONCE(task->__state) & (__TASK_STOPPED | __TASK_TRACED)) != 0)
\end{lstlisting}

\subsection{Структура \texttt{struct sysinfo}}

Структура \texttt{struct sysinfo} \cite{sysinfo} хранит информацию статистику о всей системе: информацию о времени, прошедшем с начала запуска системы, количество занятой памяти и так далее. В листинге \ref{lst:sysinfo} приведёно объявление рассматриваемой структуры.\\

\begin{lstlisting}[label=lst:sysinfo, caption=Листинг структуры \texttt{struct sysinfo}, language=c]
struct sysinfo {
	__kernel_long_t uptime;		/* Seconds since boot */
	__kernel_ulong_t loads[3];	/* 1, 5, and 15 minute load averages */
	__kernel_ulong_t totalram;	/* Total usable main memory size */
	__kernel_ulong_t sharedram;	/* Amount of shared memory */
	__kernel_ulong_t bufferram;	/* Memory used by buffers */
	__kernel_ulong_t totalswap;	/* Total swap space size */
	__kernel_ulong_t freeswap;	/* swap space still available */
	__u16 procs;		   	/* Number of current processes */
	__u16 pad;		   	/* Explicit padding for m68k */
	__kernel_ulong_t totalhigh;	/* Total high memory size */
	__kernel_ulong_t freehigh;	/* Available high memory size */
	__u32 mem_unit;			/* Memory unit size in bytes */
	char _f[20-2*sizeof(__kernel_ulong_t)-sizeof(__u32)];
};
\end{lstlisting}

Для инициализации этой структуры используется функция \texttt{si\_meminfo()}. Стоит отметить, что рассматриваемая структура не содержит информации о свободной памяти в системе. Для того чтобы получить эту информацию, необходимо воспользоваться функцией \texttt{si\_mem\_available()}.

\section{Загружаемые модули ядра}

Одной из особенностей ядра Linux является способность расширения функциональности во время работы, без необходимости компиляции ядра заново. Таким образом, существует возможность добавить (или убрать) функциональность в ядро можно когда система запущена и работает. Часть кода, которая может быть добавлена в ядро во время работы, называется модулем ядра. Ядро Linux предлагает поддержку большого числа классов модулей. Каждый модуль -- это подготовленный объектный код, который может быть динамически подключен в работающее ядро, а позднее может быть выгружен из ядра.

Каждый модуль ядра сам регистрирует себя для того, чтобы обслуживать в будущем запросы, и его функция инициализации немедленно прекращается. Задача инициализации модуля заключается в подготовке функций модуля для последующего вызова. Функция выхода модуля вызывается перед выгрузкой модуля из ядра. Функция выхода должна отменить все изменения, сделанные функций инициализации, освободить захваченные в процессе работы модуля ресурсы. 

Возможность выгрузить модуль помогает сократить время разработки -- нет необходимости перезагрузки компьютера при последовательном тестировании новых версий разрабатываемого модуля ядра.

Модуль связан только с ядром и может вызывать только те функции, которые экспортированы ядром.

\subsection{Пространство ядра и пользователя}

Приложения работаю в пользовательском пространстве, а ядро и его модули -- в пространстве ядра. Такое разделение пространств -- базовая концепция теории операционных систем.

Ролью операционной системы является обеспечение программ надёжным доступом к аппаратной части компьютера. Операционная система должна обеспечивать независимую работу программ и защиту от несанкционированного доступа к ресурсам. Решение этих задач становится возможным только в том случае, если процессор обеспечивает защиту системного программного обеспечения от прикладных программ.

Выбранный подход заключается в обеспечении разных режимов работы (или уровней) в самом центральном процессоре. Уровни играют разные роли и некоторые операции на более низких уровнях не допускаются; программный код может переключить один уровень на другой только ограниченным числом способов. Все современные процессоры имеют не менее двух уровней защиты, а некоторые, например семейство процессоров x86, имеют больше уровней; когда существует несколько уровней, используется самый высокий и самый низкий уровень защиты. 

Ядро Linux выполняется на самом высоком уровне, где разрешено выполнение любых инструкций и доступ к произвольным участкам памяти, а приложения выполняются на самом низком уровне, в котором процессор регулирует прямой доступ оборудованию и несанкционированный доступ к памяти. Ядро выполняет переход из пользовательского пространства в пространство ядра, когда приложение делает системный вызов или приостанавливается аппаратным прерыванием. Код ядра, выполняя системный вызов, работает в контексте процесса -- он действует от имени вызывающего процесса и в состоянии получить данные в адресном пространстве процесса. Код, который обрабатывает прерывания является асинхронным по отношению к процессам и не связан с каким-либо определенным процессом \cite{habr-profiling-linux}.

Ролью модуля ядра является расширение функциональности ядра без его перекомпиляции. Код модулей выполняется в пространстве ядра.

\section{Виртуальная файловая система \texttt{/proc}}

Для организации доступа к разнообразным файловым системам в Unix используется промежуточный слой абстракции -- виртуальная файловая система. С точки зрения программиста, виртуальная файловая система организована как специальный интерфейс. Виртуальная файловая система объявляет API доступа к ней, а реализацию этого API отдаёт на откуп к драйверам конкретных файловых систем.

Виртуальная файловая система \texttt{/proc} -- специальный интерфейс, с помощью которого можно мгновенно получить некоторую информацию о ядре в пространство пользователя. \texttt{/proc} отображает в виде дерева каталогов внутренние структуры ядра. 

В каталоге \texttt{/proc} в Linux присутствуют несколько деревьев файловой системы. В основном дереве, каждый каталог имеет числовое имя и соответствует процессу, с соответствующим PID. Файлы в этих каталогах соответствуют структуре \texttt{task\_struct}. Так, например, с помощью команды \texttt{cat /proc/1/cmdline}, можно узнать аргументы запуска процесса с идентификатором равным единице. В дереве \texttt{/proc/sys} отображаются внутренние переменные ядра.

Ядро предоставляет возможность добавить своё дерево в каталог \texttt{/proc}. Внутри ядра объявлена специальная структура \texttt{struct proc\_ops} \cite{proc-ops}. Эта структура содержит внутри себя указатели на функции чтения файла, записи в файла и прочие, определенные пользователем. В листинге \cite{lst:procops} представлено объявление данной структуры в ядре.

\begin{lstlisting}[label=lst:procops, caption=Листинг структуры \texttt{struct sysinfo}, language=c]
struct proc_ops {
	unsigned int proc_flags;
	int	(*proc_open)(struct inode *, struct file *);
	ssize_t	(*proc_read)(struct file *, char __user *, size_t, loff_t *);
	ssize_t (*proc_read_iter)(struct kiocb *, struct iov_iter *);
	ssize_t	(*proc_write)(struct file *, const char __user *, size_t, loff_t *);
	loff_t	(*proc_lseek)(struct file *, loff_t, int);
	int	(*proc_release)(struct inode *, struct file *);
	__poll_t (*proc_poll)(struct file *, struct poll_table_struct *);
	long	(*proc_ioctl)(struct file *, unsigned int, unsigned long);
	#ifdef CONFIG_COMPAT
	long	(*proc_compat_ioctl)(struct file *, unsigned int, unsigned long);
	#endif
	int	(*proc_mmap)(struct file *, struct vm_area_struct *);
	unsigned long (*proc_get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
} __randomize_layout;
\end{lstlisting}

С помощью вызова функций \texttt{proc\_mkdir()} и \texttt{proc\_create()} в модуле ядра можно зарегистрировать свои каталоги и файлы в \texttt{/proc} соотвественно. Функции \texttt{copy\_to\_user()} и \texttt{copy\_from\_user()} реализуют передачу данных (набора байтов) из пространства ядра в пространство пользователя и наооборот.

Таким образом, с помощью виртуальной файловой системы \texttt{/proc} можно получать (или передавать) какую-либо информацию из пространства ядра в пространство пользовтеля (из пространства пользовтаеля в пространство ядра).

\section*{Вывод}

В данном разделе были проанализированны различные подходы к трассировке ядра и перехвату функций и был выбран наиболее оптимальный метод для реализации поставленной задачи. Были рассмотрены структуры и функции ядра, предоставляющие информацию о процессах и памяти; основные принципы загружаемых модулей ядра и понятия пространств ядра и пространства пользователя, а так же рассмотрен способ взаимодействия этих двух пространств с целью передачи данных из одного в другого.



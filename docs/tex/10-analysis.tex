\chapter{Аналитическая часть}

В данном разделе будут рассмотрены и проанализированы:

\begin{itemize}
	\item различные подходы к трассировке ядра  и перехвату функций;
	\item структуры и функции ядра, предоставляющие информацию о процессах и памяти;
	\item основные принципы загружаемых модулей ядра;
	\item способы получения пользователем информации из ядра.
\end{itemize}

\section{Трассировка ядра}

Трассировка ядра -- получение информации о том, что происходит внутри работающей системы. Для этого используются специальные программные инструменты, регистрирующие все происходящие события в системе.

Такие программы могут одновременно отслеживать события как на уровне отдельных приложений, так и на уровне операционной системы. Полученная в ходе трассировки информации может оказаться полезной для диагностики и решения системных проблем.

Во время трассировки записывается информация о событиях, происходящих на низком уровне. Их количество исчисляется сотнями и даже тысячами. 

Далее будут рассмотрены существующие различные подходы к трассировке ядра и перехвату вызываемых функций, и выбран наиболее подходящий для реализации в курсовой работе.

\subsection{Linux Security Module}

\texttt{Linux Security Module} (LSM) \cite{linux-security-api} -- это специальный интерфейс, созданный для перехвата функций. В критических местах кода ядра расположены вызовы security-функций, которые вызывают коллбеки (англ. callback \cite{callback}), установленные security-модулем. Данный модуль может изучать контекст операции и принимать решение о её разрешении или запрете \cite{linux-security-api}.

Особенности рассматриваемого интерфейса:

\begin{itemize}
	\item security-модули являются частью ядра и не могу быть загружены динамически;
	\item в стандартной конфигурации сборки ядра флаг наличия LSM неактивен - большинство уже готовых сборок ядра не содержут внутри себя интерфейс LSM;
	\item в системе может быть только один security-модуль \cite{linux-security-api}.
\end{itemize}

Таким образом, для использования Linux Security Module необходимо поставлять собственную сборку ядра Linux, что является трудоёмким вариантом -- как минимум, придётся тратить время на сборку ядра. Кроме того, данный интерфейс обладает излишним функционалом (например решение о блокировке какой-либо операции), который не потребуется в написании разрабатываемого модуля ядра.

\subsection{Модификация таблицы системных вызовов}

\subsection{kprobes}

\subsection{Kernel tracepoints}

\texttt{Kernel tracepoints} \cite{kernel-tracepoints} -- это фреймворк для трассировки ядра, реализованный через статическое инструментирование кода. Большинство важных функций ядра статически инструментировано -- в теле функций добавлены вызовы функций фреймворка рассматриваемого фреймворка.

Особенности рассматриваемого фреймворка:

\begin{itemize}
	\item минимальные накладные расходы -- необходимо только вызвать функцию трассировки в необходимом месте;
	\item отсутствие задокументированного API;
	\item не все функции ядра статически инструментированны; 
	\item не работает, если ядро не сконфигурировано должным образом \cite{habr-profiling-linux}.
\end{itemize}

\subsection{ftrace}

\texttt{ftrace} \cite{ftrace} -- это фреймворк для трассировки ядра на уровне функций, реализованный на основе ключей компилятора \texttt{-pg} \cite{ftrace-habr} и \texttt{mfentry} \cite{ftrace-habr}. Данные функции вставляют в начало каждой функции вызов специальной трассировочной функции \texttt{mcount()} или \texttt{\_\_fentry()\_\_}. В пользовательских программах данная возможность компилятора используется профилировщиками, с целью отслеживания всех вызываемых функций. В ядре эти функции используются исключительно для реализации рассматриваемого фреймворка.

Для большинства современных архитектур процессора доступна оптимизация: динамический \texttt{frace} \cite{ftrace-habr}. Ядро знает расположение всех вызовов функций \texttt{mcount()} или \texttt{\_\_fentry()\_\_} и на ранних этапах загрузки ядра подменяет их машинный код на специальную машинную инструкцию \texttt{NOP} \cite{NOP}, которая ничего не делает. При включении трассировки, в нужные функции необходимые вызовы добавляются обратно. Если \texttt{ftrace} не используется, его влияние на производительность системы минимально.

Особенности рассматриваемого фреймворка:

\begin{itemize}
	\item имеется возможность перехватить любую функцию;
	\item перехват совместим с трассировкой;
	\item фреймворк зависит от конфигурации ядра, но, в популярных конфигурациях ядра (и, соответственно, в популярных образах ядра) установлены все необходимые флаги для работы; 
\end{itemize}

\subsection*{Вывод}

В таблице 1.1 приведено сравнение приведенных выше технологий трассировки ядра. 

\begin{table}[h]
	\centering
	\label{tab:analyze}
	\begin{tabular}{ | p{3cm} | p{2cm} | p{2cm} | p{2cm} | p{2cm} | p{2cm} | }
		\hline
		Название & Дин. загрузка & Перехват любых функций & Любая конфигурация ядра & Простота реализации & Наличие документации \\
		\hline
		Linux Security Module & & & & & \\
		\hline
		Модификация таблицы системных вызовов & & & & & \\
		\hline
		kprobes & & & & & \\
		\hline
		kernel tracepoints & & & & &  \\
		\hline
		ftrace & & & & & \\
		\hline
	\end{tabular}
	\caption{Сравнение технологий, позволяющих трассировать ядро}
\end{table}

В ходе анализа подходов к перехвату функций, был выбран фреймворк \texttt{ftrace}, так как он позволяет перехватить любую функцию зная лишь её имя, может быть загружен в ядро динамически и не требует специальной сборки ядра и имеет хорошо задокументированный API.

\section{Информация о процессах и памяти}

\section{Загружаемые модули ядра}

Одной из особенностей ядра Linux является способность расширения функциональности во время работы, без необходимости компиляции ядра заново. Таким образом, существует возможность добавить (или убрать) функциональность в ядро можно когда система запущена и работает. Часть кода, которая может быть добавлена в ядро во время работы, называется модулем ядра. Ядро Linux предлагает поддержку большого числа классов модулей. Каждый модуль -- это подготовленный объектный код, который может быть динамически подключен в работающее ядро, а позднее может быть выгружен из ядра.

Каждый модуль ядра сам регистрирует себя для того, чтобы обслуживать в будущем запросы, и его функция инициализации немедленно прекращается. Задача инициализации модуля заключается в подготовке функций модуля для последующего вызова. Функция выхода модуля вызывается перед выгрузкой модуля из ядра. Функция выхода должна отменить все изменения, сделанные функций инициализации, освободить захваченные в процессе работы модуля ресурсы. 

Возможность выгрузить модуль помогает сократить время разработки -- нет необходимости перезагрузки компьютера при последовательном тестировании новых версий разрабатываемого модуля ядра.

Модуль связан только с ядром и может вызывать только те функции, которые экспортированы ядром.

\section{Получение данных из ядра}

\section*{Вывод}



В данном разделе:


